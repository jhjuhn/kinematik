<!DOCTYPE HTML>
<html>

<head>
<meta charset=utf-8>
<title>kinematik</title>

<style>
* { margin: 0; padding: 0; }
html, body {
	margin: 0;
	padding: 0;
}
canvas { display: block; }
</style>

<!-- external libraries -->
<script src="three.min.js"></script>
<script src="numeric-1.2.6.min.js"></script>


<script src="three.orbitcontrols.js"></script>

<script src="v4.js"></script>
<script src="denavithartenberg.js"></script>
<script src="frame.js"></script>

<script>
var KINEMATIK_JOINTTYPE_REVOLUTE = 1;
var KINEMATIK_JOINTTYPE_PRISMATIC = 2;

var kinematik = {};


// KinematicChain:	constructor for kinematic chain object.
//
//			members:
//
//			links:	an array of links belonging
//				to this kinematic chain.

kinematik.KinematicChain = function(){
	this.links = [];
	return this;
}

// pushlink:	appends a new link to the end of the current kinematic chain,
//		and sets its prev member appropriately. This is the advised
//		method to add links to the chain.

kinematik.KinematicChain.prototype.pushlink = function(){
	this.links.push(new kinematik.KinematicLink());

	this.links[this.links.length-1].prev = 
	this.links[this.links.length-2];
}

// poplink:	removes the last link from the kinematic chain. Note that this
//		function does not consider the representation of the link, and
//		visual_remove should be called on the link to be removed before
//		this function removes the data to prevent garbage from remaining
//		on the scene.

kinematik.KinematicChain.prototype.poplink = function(){
	this.links.pop();
}


// data_fromDH:	works pretty much the same way as KinematicLink.data_fromDH.
//		calls data_fromDH for each link in the correct sequence for
//		propagation of transformations. Optionally newDHlist, an
//		array of DenavitHartenberg objects, may be supplied, in which
//		case the function will pass the i-th element in that list as
//		the argument when calling KinematicLink.data_fromDH on the i-th
//		link.

kinematik.KinematicChain.prototype.data_fromDH = function(newDHlist){
	for (var i = 0; i < this.links.length; ++i) {
	this.links[i].data_fromDH(
		(newDHlist && newDHlist[i] instanceof DenavitHartenberg) ?
		newDHlist[i] : null
		);
	}	
}

// visual_init:	create objects to form visual representations of each link of
//		the kinematic chain.

kinematik.KinematicChain.prototype.visual_init = function(camera, renderer, scene){
	for (var i = 0; i < this.links.length; ++i) {
	this.links[i].visual_init(camera, renderer, scene);
	}
}

// visual_sync:	updates position and orientation of visual representation

kinematik.KinematicChain.prototype.visual_sync = function(){
	for (var i = 0; i < this.links.length; ++i) {
	this.links[i].visual_sync();
	}
}



// KinematicLink:	constructor for kinematic link object to be included
//			in a kinematic chain.
//
//			assuming it is the 0-indexed i-th link in chain, and
//			is therefore moved by the 1-indexed i-th joint, and
//			associated with	the 0-indexed i-th frame.
//
//			jointtype: either revolute or prismatic.
//
//			DH:	Denavit-Hartenberg parameters.
//
//			prev:	previous link. Maintained by user effort - it is
//				encouraged to always carry out link operations on
//				kinematicChain level to prevent this from breaking.
//
//			frame:	object representing frame i.
//
//			T:	the 4-matrix T_i, which gives the transformation
//				from the inertial frame at origin to frame i.
//
//			A:	the 4-matrix A_i, which gives transformation from
//				frame i-1 to frame i. Notice that we have T_i =
//				T_{i-1} A_i.
//

kinematik.KinematicLink = function(){
	this.jointtype = KINEMATIK_JOINTTYPE_REVOLUTE;

	this.prev = null;

	this.DH = new DenavitHartenberg();
	this.frame = new Frame();

	this.T = numeric.identity(4);
	this.A = numeric.identity(4);

	this.localjointlocation = [0, 0, 0, 1];

	this.visual = null;
	return this;
}


// data_fromDH:	sets the DH member to newDH if supplied. Then updates all the
//		other members to agree with DH.
//
//		this function requires the prev member to be properly set. also
//		notice that the method doesn't touch the localjointlocation member:
//		it is defaulted to the zero vector upon init and, if set with
//		data_fromjoint later on, will remain set when DH are updated.

kinematik.KinematicLink.prototype.data_fromDH = function(newDH){

	if (newDH instanceof DenavitHartenberg) { this.DH = newDH; }

	this.A = this.DH.tomat4();
	this.T = this.A;
	if (this.prev instanceof kinematik.KinematicLink) {
		this.T = numeric.dot(
		this.prev.T, this.A);
	}
	this.frame.transform_mat4set(this.T);
}


// data_fromjoint:	calculates the DH parameters from the location of the
//			joint, given in world coordinates, and information of
//			the previous joint; and then calls data_fromDH to update
//			everything else.

kinematik.KinematicLink.prototype.data_fromjoint = function(newjoint){
	if (!newjoint) {
		console.log("! invalid joint object");
		return;
	}

	this.jointtype = newjoint.jointtype || KINEMATIC_JOINTTYPE_REVOLUTE;
	
	var prevframe = this.prev instanceof kinematik.KinematicLink ?
			this.prev.frame : new Frame();

	//console.log(newjoint.jointaxis.v4unit());

	// calculate D-H parameters
	var d = 0;
	var t = 0;
	var r = 0;
	var a = 0;
	newjoint.jointaxis.v4unit();

	// check for integrity of the specification for the new axis.
	if (newjoint.jointaxis.v4epsilon()) {
		console.log("! joint axis has zero norm");
		return;
	}

	// case : z_n-1 and z_n are parallel.
	//
	// -	the choice of d is arbitrary and we set it to 0.
	//
	// -	x_n is in the direction of the common normal, pointing from
	//	z_n to z_n-1 and t can be calculated accordingly. If the
	//	common normal vanishes, x_n = x_n-1 and t = 0;
	//
       	// -	r is calculated from the magnitude of the common normal.
	//
	// -	a is zero since z_n-1 // z_n.
	//

	if (v4x(prevframe.axis[2], newjoint.jointaxis).v4epsilon()) {
		console.log("parallel.");

		var normalvector = v4sub(
				newjoint.jointlocation,
				prevframe.o).v4projontoplane(
				prevframe.axis[2]);
		d = 0;
		if (normalvector.v4epsilon()) {
			t = 0;
			r = 0;
		} else {
			// notice the +PI on t and the sign on r:
			// we choose x_n such that it points /towards/
			// the previous link.
			t = Math.PI+v4ang(normalvector,
				prevframe.axis[0],
				prevframe.axis[2]);
			r = -normalvector.v4mag();
		}
		a = 0;
	}
	// case: z_n-1 and z_n are not parallel.
	//
	// -	d is the offset along z_n-1 to endpoint of common normal. This
	//	involves solving an equation for the endpoints.
	//
	// -	x_n is, as in the parallel case, the direction of the common normal
	//	pointing from z_n to z_n-1
	// -	r is calculated the magnitude from the common normal.
	// -	

	else {
		var diffvector = v4sub(newjoint.jointlocation, prevframe.o);
		var normalvector = v4projontovector(diffvector,
				v4x(newjoint.jointaxis, prevframe.axis[2])
				);	

		// solving the equations.
		// (diffvector + k z_n - d z_n-1) . z_n-1 = 0
		// (diffvector + k z_n - d z_n-1) . z_n   = 0
		// we need only d so matrix shenanigans will probably
		// be overkill.

		var z_n = newjoint.jointaxis;
		var z_0 = prevframe.axis[2];

		// so here. have a manual gaussian elimination.

		var factor = v4dot(z_n, z_0)/v4dot(z_n, z_n);
		d = (v4dot(diffvector, z_0) - factor*v4dot(diffvector, z_n))/
		(v4dot(z_0, z_0) - factor*v4dot(z_n, z_0));

		// if the normal vector vanishes, the two axes coincide.
		if (normalvector.v4epsilon()) {
			t = v4ang(prevframe.axis[0], prevframe.axis[2]);
			r = 0;
			a = v4ang(z_n, z_0);
		} else {
			t = v4ang(normalvector,
				prevframe.axis[0],
				prevframe.axis[2]);
			r = normalvector.v4mag();	
			a = v4ang(z_n, z_0, normalvector);
		}

	}



	var newDH = new DenavitHartenberg(d, t, r, a);

	this.data_fromDH(newDH);

	this.localjointlocation = this.frame.globaltolocal(newjoint.jointlocation);

}


// actuate:	updates appropriate joint parameter (theta for revolute, d for
//		prismatic joints) to jparam, and calls data_fromDH to update
//		all the data.

kinematik.KinematicLink.prototype.actuate = function(jparam){
	if (this.jointtype === KINEMATIK_JOINTTYPE_REVOLUTE) { this.DH.t = jparam; }
	else if (this.jointtype === KINEMATIK_JOINTTYPE_PRISMATIC) { this.DH.d = jparam; }
	else { console.log("! unknown joint type."); return; }

	this.data_fromDH(null);	
}


// some constants that determine the appearance of webGL visual representation
// of the links.

var KINEMATIK_KINEMATICLINK_MATERIAL = new THREE.MeshNormalMaterial();

var KINEMATIK_KINEMATICLINK_GEOMETRY_SHAFT_THICKNESS = 0.1;


// visual_init:	creates webGL objects for visual representation of link and
//		adds them to the scene.

kinematik.KinematicLink.prototype.visual_init = function(camera, renderer, scene){
	if (this.visual !== null) {
		console.log("! repeated call to visual_init");
		return;
	}

	// initialise visual for associated frame.
	this.frame.visual_init(camera, renderer, scene);


	this.visual = {
		shaft:	new THREE.Mesh(
			new THREE.BoxGeometry(
			KINEMATIK_KINEMATICLINK_GEOMETRY_SHAFT_THICKNESS,
			KINEMATIK_KINEMATICLINK_GEOMETRY_SHAFT_THICKNESS, 1),
			KINEMATIK_KINEMATICLINK_MATERIAL)
	};

	scene.add(this.visual.shaft);
}

// visual_sync:	updates the position and orientation of visual representation
//		to reflect the sate of the link.

kinematik.KinematicLink.prototype.visual_sync = function(){
	if (this.visual === null) {
		console.log("! call to visual_sync without initialised visual");
		return;
	}
	
	// shaft connects the present joint to the next one. the two
	// endpoints are calculated here.
	var toe = this.prev instanceof kinematik.KinematicLink ?
		this.prev.frame.localtoglobal(this.prev.localjointlocation) :
		[0, 0, 0, 1];
	var tip = this.frame.localtoglobal(this.localjointlocation);
	var shaftvector = v4sub(tip, toe);
	var midpoint = v4add(toe, tip).v4mul(0.5);

	// check for zero-length links so that scaling doesn't break matrices.
	// if the length is zero, just don't render the shaft.
	if (shaftvector.v4epsilon()) {
		this.visual.shaft.scale.z = 1;
		this.visual.shaft.visible = false;
	} else {
		this.visual.shaft.scale.z = shaftvector.v4mag();
		this.visual.shaft.visible = true;
	}


	this.visual.shaft.position.fromArray(midpoint);

	// we want to consistently orient the shaft so that it doesn't spin about
	// arbitrarily on its axis. we choose from the x and z axes of the present frame,
	// whichever is numerically nicer.
	this.visual.shaft.up.fromArray(
			Math.abs(v4dot(this.frame.axis[2], shaftvector)) <
			Math.abs(v4dot(this.frame.axis[0], shaftvector)) ?
			this.frame.axis[2] : this.frame.axis[0]
	);
	
	this.visual.shaft.lookAt(new THREE.Vector3().fromArray(tip));

	this.frame.visual_sync();
}


// visual_remove:	removes the visual representation from the scene, deletes
//			the relevant objects, and sets visual back to null.

kinematik.KinematicLink.prototype.visual_remove = function(camera, renderer, scene){
	if (this.visual === null) {
		console.log("! call to visual_remove without initialised visual");
		return;
	}
	this.frame.visual_remove(camera, renderer, scene);

	scene.remove(this.visual.shaft);

	this.visual = null;
}

</script>


<!-- main.js -->
<script>
var camera;
var renderer;
var scene;

var orbitcontrols;

function initTHREE(){
	// initialise camera
	camera = new THREE.PerspectiveCamera(
		45,
		window.innerWidth/window.innerHeight,
		0.1, 1000 );
	
	// initial position of camera
	camera.up.set(0, 0, 1);
	camera.position.z = 10;

	// initialise renderer and scene
	renderer = new THREE.WebGLRenderer();
	scene = new THREE.Scene();

	var refplane = new THREE.Mesh(
			new THREE.PlaneGeometry(1, 1),
			new THREE.MeshBasicMaterial({ color: 0x333333 }));
	scene.add(refplane);

	// append canvas to document
	document.body.appendChild(renderer.domElement);

}

var manipulator = null;
function init(){
	initTHREE(); // init webGL things

	manipulator = new kinematik.KinematicChain();
	for (var i = 0; i < 4; ++i) {
	manipulator.pushlink();
	}
	manipulator.links[0].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.2, 0.2, 0.4, 1],
		jointaxis: [1, 0, 0, 1]
	});
	manipulator.links[1].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.2, 0.3, 1.4, 1],
		jointaxis: [1, 0, 0, 1]
	});
	manipulator.links[2].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.0, 0.3, 1.4, 1],
		jointaxis: [0, 1, 0, 1]
	});

	manipulator.visual_init(camera, renderer, scene);
	

	orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);
}

function render(){
	// adjust camera and renderer in response to any viewport size change.
	camera.aspect = window.innerWidth/window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize(window.innerWidth, window.innerHeight);

	// render the scene as seen through camera.
	renderer.render(scene, camera);
}

var _t = 0;
function timestep(){
	_t += 0.01;

	manipulator.links[1].actuate(_t);

	manipulator.data_fromDH(null);
	manipulator.visual_sync();

	requestAnimationFrame(timestep);

	render();
}


</script>

</head>
<body></body>
<script>init(); timestep(); </script>
</html>
