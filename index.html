<!DOCTYPE HTML>
<html>

<head>
<meta charset=utf-8>
<title>kinematik</title>

<style>
* { margin: 0; padding: 0; }
html, body {
	margin: 0;
	padding: 0;

	width: 100%;
	height: 100%;
}
#viewport {
	display: block;
	width: 100%;
	height: 100%;
}
</style>

<!-- external libraries -->
<script src="three.min.js"></script>
<script src="numeric-1.2.6.min.js"></script>


<script src="orbitcontrols.js"></script>

<script src="v4.js"></script>
<script src="denavithartenberg.js"></script>
<script src="frame.js"></script>

<script src="kinematik.js"></script>


<!-- cursor.js -->
<script>
// declarations for user interaction
function Cursor(camera, renderer, scene){

	this.camera = camera;
	this.renderer = renderer;

	this.raycaster = new THREE.Raycaster();

	// current coordinates of the /mouse/ (not the 3d cursor)
	this.q2d = [0, 0];
	this.q3d = [0, 0, 0, 1];
	// coordinates at the beginning of tentative operations that will
	// be returned to if the operation is aborted.
	this.marker2d = [0, 0];
	this.marker3d = [0, 0, 0, 1];

	this.state = {
		translation: false,
		rotation: false,
		axis: null
	};

	this.frame = new Frame();
	this.prevframe = new Frame();

	this.visual = null;

	this.attachhandlers(camera, renderer, scene);

	return this;
}
Cursor.prototype.visual_init = function(camera, renderer, scene){
	// camera, renderer, scene are supplied for consistency, even
	// though the object has memory of camera & renderer upon
	// initialisation. If the parameters here are inconsistent with
	// the one supplied to the constructor, the class will calculate
	// the projection into one scene but draw the 3d cursor in another,
	// which is silly.

	if (this.visual !== null) {
		console.log("! repeated call to visual_init");
		return;
	}
	this.visual = {};
	
	// placeholder: sphere marks location of cursor.
	this.visual.centre = new THREE.Mesh(
			new THREE.SphereGeometry(0.01, 32, 32),
			new THREE.MeshBasicMaterial({color: 0x666666 })
			);
	scene.add(this.visual.centre);

	// also initalise visuals for associated frame
	this.frame.visual_init(camera, renderer, scene);
	//this.prevframe.visual_init(camera, renderer, scene);
}
Cursor.prototype.visual_sync = function(){
	if (this.visual === null) {
		console.log("! call to visual_sync without intialised visual");
		return;
	}
	this.visual.centre.position.fromArray(this.q3d);

	this.frame.visual_sync();
	//this.prevframe.visual_sync();
}
Cursor.prototype.q2d_fromevent = function(e){
	// 2d (screen space) coordinates from mouse event.
	//
	// we use the canvas convention of coordinates with origin
	// at centre of element & coordinates normalised to
	// (-1, 1) along both axes.
	var q2d = [
	e.clientX/e.target.clientWidth*2-1,
	-e.clientY/e.target.clientHeight*2+1
	];
	return q2d;
}
Cursor.prototype.q3d_fromevent = function(e, ref) {
	var q2d = [e.clientX/e.target.clientWidth*2-1,
	-e.clientY/e.target.clientHeight*2+1];

	// 3d (scene space) coordinates:
	//
	// a ray is cast from cursor coordinates, and this.q3d is
	// moved to the point on that ray that leaves its distance to
	// the camera, along the camera's viewing vector, unchanged.

	this.raycaster.setFromCamera(
			new THREE.Vector2().fromArray(ref),
			this.camera);

	var ray = v4fromTHREEVector3(this.raycaster.ray.direction);
	var origin = v4fromTHREEVector3(this.raycaster.ray.origin);
	var cameradirection = v4fromTHREEVector3(this.camera.getWorldDirection());

	// the distance down the cast ray to the intersection with the normal plane.
	var scale = v4dot(cameradirection, v4sub(this.q3d, origin))/
	v4dot(cameradirection, ray);

	return v4add(origin, v4mul(scale, ray));
}
Cursor.prototype.q3d_setfromevent = function(e, ref){
	this.q3d = this.q3d_fromevent(e, ref);
}
Cursor.prototype.q2d_setfromevent = function(e){ this.q2d = this.q2d_fromevent(e); }


Cursor.prototype.keydownhandler = function(e){
	console.log("keydown: " + e.which);

	if (e.which == 27) { this.action_abort(); }		// ESC
	if (e.which == 82) { this.rotation_start(); }		// RKEY
	if (e.which == 84) { this.translation_start(); }	// TKEY

	// X, Y, Z keys set axis
	if (e.which == 88) {
		if (this.state.translation || this.state.rotation) {
		this.state.axis = this.frame.axis[0]; }
	}
	if (e.which == 89) {
		if (this.state.translation || this.state.rotation) {
		this.state.axis = this.frame.axis[1]; }
	}
	if (e.which == 90) {
		if (this.state.translation || this.state.rotation) {
		this.state.axis = this.frame.axis[2]; }
	}
}

Cursor.prototype.mousemovehandler = function(e){
	// always track where the mouse is, in both
	// screen and scene space.
	this.q2d_setfromevent(e);
	this.q3d_setfromevent(e, this.q2d);

	if (this.state.translation) { this.translation_sync(); }
	if (this.state.rotation) { this.rotation_sync(); }
}
Cursor.prototype.mousedownhandler = function(e){
	this.q2d_setfromevent(e);
	this.q3d_setfromevent(e, this.q2d);

	if (this.state.translation || this.state.rotation) { this.action_apply();
	} else {
		// no special state actions.
		// move the cursor upon LMB click.
		if (e.which == 1) {
			this.frame.transform_set(this.q3d, null);
		}
	}
	
}
Cursor.prototype.wheelhandler = function(e){
	this.q2d_fromevent(e);
}
Cursor.prototype.attachhandlers = function(camera, renderer, scene) {
	window.addEventListener("keydown",
			this.keydownhandler.bind(this));

	renderer.domElement.addEventListener("mousemove",
			this.mousemovehandler.bind(this));
	renderer.domElement.addEventListener("mousedown",
			this.mousedownhandler.bind(this));
	renderer.domElement.addEventListener("wheel",
			this.wheelhandler.bind(this));
}

Cursor.prototype.translation_start = function(){
	this.state.translation = true;
	this.state.rotation = false;

	this.marker2d = this.q2d;
	this.marker3d = this.q3d;
	this.prevframe.transform_frameset(this.frame);
}
Cursor.prototype.translation_sync = function(){
	var delta = v4sub(this.q3d, this.marker3d);
	if (this.state.axis) {
		delta = v4mul(
			v4dot(this.state.axis, delta),
			this.state.axis);
	}
	this.frame.transform_set(
	v4add(this.prevframe.o, delta),
	null);
}
Cursor.prototype.rotation_start = function(){
	this.state.translation = false;
	this.state.rotation = true;

	this.marker2d = this.q2d;
	this.marker3d = this.q3d;
	this.prevframe.transform_frameset(this.frame);
}
Cursor.prototype.rotation_sync = function(){

}
Cursor.prototype.action_apply = function(){
	// remove all the state tags and leave the frame
	// in the state of the latest update.
	this.state.translation = false;
	this.state.rotation = false;
	this.state.axis = null;
}
Cursor.prototype.action_abort = function(){
	// restore configuration of frame
	this.frame.transform_frameset(this.prevframe);

	// reset state
	this.state.translation = false;
	this.state.rotation = false;
	this.state.axis = null;
}

Cursor.prototype.update = function(){

}
</script>

<!-- main.js -->
<script>
var cursor;

// declarations for THREE
var camera;
var renderer;
var scene;

var orbitcontrols;

function initTHREE(){
	// initialise camera
	var canvas = document.getElementById("viewport");
	camera = new THREE.PerspectiveCamera(
		45,
		canvas.clientWidth/canvas.clientHeight,
		//window.innerWidth/window.innerHeight,
		0.1, 1000 );
	
	// initial position of camera
	camera.up.set(0, 0, 1);
	camera.position.z = 2;

	// initialise renderer and scene
	renderer = new THREE.WebGLRenderer({ canvas: canvas });
	scene = new THREE.Scene();

	scene.background = new THREE.Color(0xf4f4f4);

	// populate scene with reference plane and light
	var refplane = new THREE.Mesh(
			new THREE.PlaneGeometry(1, 1),
			new THREE.MeshBasicMaterial({ color: 0xfafafa }));
	scene.add(refplane);

	var ambientlight = new THREE.AmbientLight(0xffffff);
	scene.add(ambientlight);
	var directionallight = new THREE.DirectionalLight(0xffffff, 0.8);
	directionallight.position.set(10, 10, 10);
	scene.add(directionallight);


	// suppress mouse events
	renderer.domElement.addEventListener("contextmenu", function(e){ e.preventDefault(); });
}

// declarations for kinematik
var manipulator = null;
function init(){
	initTHREE(); // init webGL things

	// init manipulator
	manipulator = new kinematik.KinematicChain();
	manipulator.visual_init(camera, renderer, scene);

	// COMMENTED OUT: code to generate a random manipulator.
	/*
	var nextjq = [0, 0, 0, 1];
	var nextjz = [0, 0, 0, 1];
	for (var i = 0; i < 6; ++i) {
		nextjq.v4add(
		[Math.random(), Math.random(), Math.random(), 1].v4mul(0.15));
		nextjz = [Math.random(), Math.random(), Math.random(), 1];

		manipulator.pushlink();
		manipulator.links[i].data_fromjoint({
			jointtype: (Math.random() > 0.5 ? 1 : 2),
			jointlocation: nextjq,
			jointaxis: nextjz
		});
	}
	manipulator.visual_init(camera, renderer, scene);
	*/


	// typical anthropomorphic manipulator:
	for (var i = 0; i < 6; ++i) { manipulator.pushlink(); }
	manipulator.links[0].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0, 0.1, 1],
		jointaxis: [0, 0, 1, 1] });

	manipulator.links[1].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.12, 0, 0.2, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[2].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.1, 0, 0.6, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[3].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.1, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.links[4].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.links[4].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[5].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.visual_init(camera, renderer, scene);

	// init interaction
	cursor = new Cursor(camera, renderer, scene);
	cursor.visual_init(camera, renderer, scene);

	orbitcontrols = new Orbitcontrols(camera, renderer, scene);

	//orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);

}

function render(){
	renderer.setSize(renderer.domElement.clientWidth,
			renderer.domElement.clientHeight, false);

	// adjust camera and renderer in response to any viewport size change.
	camera.aspect = renderer.domElement.clientWidth/
			renderer.domElement.clientHeight;
	camera.updateProjectionMatrix();


	// update visual for the manipulator
	manipulator.visual_sync();

	// update controls
	cursor.update();
	cursor.visual_sync();

	orbitcontrols.update();
	orbitcontrols.visual_sync();


	// render the scene as seen through camera.
	renderer.render(scene, camera);
}

var _t = 0;
function timestep(){
	_t += 0.01;

	manipulator.data_fromDH(null);

	requestAnimationFrame(timestep);

	render();
}


</script>

</head>
<body>
	<canvas id="viewport">
	</canvas>

</body>
<script>init(); timestep(); </script>
</html>
