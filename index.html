<!DOCTYPE HTML>
<html>

<head>
<meta charset=utf-8>
<title>kinematik</title>

<style>
* { margin: 0; padding: 0; }
html, body {
	margin: 0;
	padding: 0;

	width: 100%;
	height: 100%;
}
#viewport {
	display: block;
	width: 100%;
	height: 100%;
}
</style>

<!-- external libraries -->
<script src="three.min.js"></script>
<script src="numeric-1.2.6.min.js"></script>


<!--<script src="three.orbitcontrols.js"></script>-->
<script>
function Orbitcontrols(camera, renderer, scene){
	
	this.camera = camera;
	this.renderer = renderer;

	this.dragstart = {};
	this.dragstart.q2d = [0, 0];
	this.dragstart.qspherical = {
		o: [0, 0, 0, 1],
		r: 2,
		t: 0,
		f: Math.PI/2
	}

	// records whether and how mouse events affect
	// movement of camera.
	this.state = {
		rotation: false,
		translation: false
		};

	// the position of the camera in spherical coords.
	this.qspherical = {
		o: [0, 0, 0, 1],	// origin
		r: 2,			// radial distance
		t: -Math.PI/2,		// azimuth
		f: Math.PI/2		// elevation
	};


	this.attachhandlers(camera, renderer, scene);

	return this;
}
Orbitcontrols.prototype.qspherical_clamp = function(){
	// clamp the coordinate values to prevent accidentally
	// dividing by zero elsewhere.

	while (this.qspherical.t >  2*Math.PI) { this.qspherical.t -= 2*Math.PI; }
	while (this.qspherical.t < 0) { this.qspherical.t += 2*Math.PI; }

	this.qspherical.f = Math.min(this.qspherical.f, Math.PI/2-1e-6);
	this.qspherical.f = Math.max(this.qspherical.f, 1e-6-Math.PI/2);
}

Orbitcontrols.prototype.qspherical_fromcamera = function(){
	var q = v4fromTHREEVector3(
	this.camera.position).v4sub(this.qspherical.o);

}

Orbitcontrols.prototype.camera_fromqspherical = function(newsphq){

	// if new coordinates are supplied, update the spherical
	// coordinates to agree with the new ones. If this method
	// is called w/o argument, then it just syncs the camera
	// position with the stored spherical coords.
	if (newsphq !== undefined) {
		if (newsphq.o !== undefined) { this.qspherical.o = newsphq.o; }
		if (newsphq.r !== undefined) { this.qspherical.r = newsphq.r; }
		if (newsphq.t !== undefined) { this.qspherical.t = newsphq.t; }
		if (newsphq.f !== undefined) { this.qspherical.f = newsphq.f; }
	}
	this.qspherical_clamp();

	// calculate cartesian coordinates from spherical ones
	// and assign the result to the camera position.
	var newq = [
		this.qspherical.r*Math.cos(this.qspherical.f)
			*Math.cos(this.qspherical.t),
		this.qspherical.r*Math.cos(this.qspherical.f)
			*Math.sin(this.qspherical.t),
		this.qspherical.r*Math.sin(this.qspherical.f),
		1
	];
	this.camera.position.fromArray(newq);

	this.camera.lookAt(new THREE.Vector3().fromArray(this.qspherical.o));
	
}

Orbitcontrols.prototype.mousedownhandler = function(e){
	var q2d = [
		e.clientX/e.target.clientWidth*2-1,
		-e.clientY/e.target.clientHeight*2+1];

	// if the camera is not already being moved, and the MMB is down,
	// set the state such that mouse movement moves camera.
	if ((e.which == 2) && !(this.state.translation || this.state.rotation)){
		this.dragstart.q2d = q2d;
		this.dragstart.qspherical = {
			o: this.qspherical.o, r: this.qspherical.r,
			t: this.qspherical.t, f: this.qspherical.f };

		(e.shiftKey) ?
		this.state.translation = true :
		this.state.rotation = true;
	}
}

Orbitcontrols.prototype.mousemovehandler = function(e){
	// if currently moving the camera, calculate movement accordingly
	var dq2d = [
		(e.clientX/e.target.clientWidth*2-1) - this.dragstart.q2d[0],
		(1-e.clientY/e.target.clientHeight*2) - this.dragstart.q2d[1]
	];

	if (this.state.rotation) {
		this.qspherical.t = this.dragstart.qspherical.t - 4*dq2d[0];
		this.qspherical.f = this.dragstart.qspherical.f - 2*dq2d[1];
	}
}

Orbitcontrols.prototype.mouseuphandler = function(e){
	var q2d = [
		e.clientX/e.target.clientWidth*2-1,
		-e.clientY/e.target.clientHeight*2+1];

	// there's an assumption that the mouse can't be doing more than one
	// thing at once (the mousedown handler doesn't trigger any additional
	// statechanges once there is already an active state), so everytime
	// a button is lifted it is safe to clear all states.
	this.state.translation = false;
	this.state.rotation = false;
}

Orbitcontrols.prototype.attachhandlers = function(camera, renderer, scene){
	renderer.domElement.addEventListener(
			"mousedown", this.mousedownhandler.bind(this));
	renderer.domElement.addEventListener(
			"mousemove", this.mousemovehandler.bind(this));
	renderer.domElement.addEventListener(
			"mouseup", this.mouseuphandler.bind(this));
}

</script>

<script src="v4.js"></script>
<script src="denavithartenberg.js"></script>
<script src="frame.js"></script>

<script src="kinematik.js"></script>


<!-- cursor.js -->
<script>
// declarations for user interaction
function Cursor(camera, renderer, scene){

	this.camera = camera;
	this.renderer = renderer;

	this.raycaster = new THREE.Raycaster();

	this.q2d = [0, 0];
	this.q3d = [0, 0, 0, 1];

	this.marker2d = [0, 0];
	this.marker3d = [0, 0, 0, 1];

	this.visual = null;

	this.attachhandlers(camera, renderer, scene);

	return this;
}
Cursor.prototype.visual_init = function(camera, renderer, scene){
	// camera, renderer, scene are supplied for consistency, even
	// though the object has memory of camera & renderer upon
	// initialisation. If the parameters here are inconsistent with
	// the one supplied to the constructor, the class will calculate
	// the projection into one scene but draw the 3d cursor in another,
	// which is silly.

	if (this.visual !== null) {
		console.log("! repeated call to visual_init");
		return;
	}
	this.visual = {};
	
	// placeholder: sphere marks location of cursor.
	this.visual.centre = new THREE.Mesh(
			new THREE.SphereGeometry(0.01, 32, 32),
			new THREE.MeshBasicMaterial({color: 0x666666 })
			);
	scene.add(this.visual.centre);
}
Cursor.prototype.visual_sync = function(){
	if (this.visual === null) {
		console.log("! call to visual_sync without intialised visual");
		return;
	}
	this.visual.centre.position.fromArray(this.q3d);
}
Cursor.prototype.q2d_fromevent = function(e){
	// 2d (screen space) coordinates from mouse event.
	//
	// we use the canvas convention of coordinates with origin
	// at centre of element & coordinates normalised to
	// (-1, 1) along both axes.

	this.q2d[0] = e.clientX/e.target.clientWidth*2-1;
	this.q2d[1] = -e.clientY/e.target.clientHeight*2+1;
}
Cursor.prototype.q3d_fromevent = function(e) {

	var q2d = [e.clientX/e.target.clientWidth*2-1,
	-e.clientY/e.target.clientHeight*2+1];

	// 3d (scene space) coordinates:
	//
	// a ray is cast from cursor coordinates, and this.q3d is
	// moved to the point on that ray that leaves its distance to
	// the camera, along the camera's viewing vector, unchanged.

	this.raycaster.setFromCamera(
			new THREE.Vector2().fromArray(q2d),
			this.camera);

	var ray = v4fromTHREEVector3(this.raycaster.ray.direction);
	var origin = v4fromTHREEVector3(this.raycaster.ray.origin);
	var cameradirection = v4fromTHREEVector3(this.camera.getWorldDirection());

	// the distance down the cast ray to the intersection with the normal plane.
	var scale = v4dot(cameradirection, v4sub(this.q3d, origin))/v4dot(cameradirection, ray);

	this.q3d = v4add(origin, v4mul(scale, ray));

}
Cursor.prototype.mousemovehandler = function(e){
	this.q2d_fromevent(e);
	//this.q3d_fromevent(e);
}
Cursor.prototype.mousedownhandler = function(e) {
	this.q2d_fromevent(e);
	this.q3d_fromevent(e);

}
Cursor.prototype.wheelhandler = function(e) {
	this.q2d_fromevent(e);
}
Cursor.prototype.attachhandlers = function(camera, renderer, scene) {
	renderer.domElement.addEventListener("mousemove",
			this.mousemovehandler.bind(this));
	renderer.domElement.addEventListener("mousedown",
			this.mousedownhandler.bind(this));
	renderer.domElement.addEventListener("wheel",
			this.wheelhandler.bind(this));
}
</script>

<!-- main.js -->
<script>
var cursor;

// declarations for THREE
var camera;
var renderer;
var scene;

var orbitcontrols;

function initTHREE(){
	// initialise camera
	var canvas = document.getElementById("viewport");
	camera = new THREE.PerspectiveCamera(
		45,
		canvas.clientWidth/canvas.clientHeight,
		//window.innerWidth/window.innerHeight,
		0.1, 1000 );
	
	// initial position of camera
	camera.up.set(0, 0, 1);
	camera.position.z = 2;

	// initialise renderer and scene
	renderer = new THREE.WebGLRenderer({ canvas: canvas });
	scene = new THREE.Scene();

	scene.background = new THREE.Color(0xf4f4f4);

	// populate scene with reference plane and light
	var refplane = new THREE.Mesh(
			new THREE.PlaneGeometry(1, 1),
			new THREE.MeshBasicMaterial({ color: 0xfafafa }));
	scene.add(refplane);

	var ambientlight = new THREE.AmbientLight(0xffffff);
	scene.add(ambientlight);
	var directionallight = new THREE.DirectionalLight(0xffffff, 0.8);
	directionallight.position.set(10, 10, 10);
	scene.add(directionallight);


	// suppress mouse events
	renderer.domElement.addEventListener("contextmenu", function(e){ e.preventDefault(); });
}

// declarations for kinematik
var manipulator = null;
function init(){
	initTHREE(); // init webGL things

	// init manipulator
	manipulator = new kinematik.KinematicChain();
	manipulator.visual_init(camera, renderer, scene);

	// COMMENTED OUT: code to generate a random manipulator.
	/*
	var nextjq = [0, 0, 0, 1];
	var nextjz = [0, 0, 0, 1];
	for (var i = 0; i < 6; ++i) {
		nextjq.v4add(
		[Math.random(), Math.random(), Math.random(), 1].v4mul(0.15));
		nextjz = [Math.random(), Math.random(), Math.random(), 1];

		manipulator.pushlink();
		manipulator.links[i].data_fromjoint({
			jointtype: (Math.random() > 0.5 ? 1 : 2),
			jointlocation: nextjq,
			jointaxis: nextjz
		});
	}
	manipulator.visual_init(camera, renderer, scene);
	*/


	// typical anthropomorphic manipulator:
	for (var i = 0; i < 6; ++i) { manipulator.pushlink(); }
	manipulator.links[0].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0, 0.1, 1],
		jointaxis: [0, 0, 1, 1] });

	manipulator.links[1].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.12, 0, 0.2, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[2].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.1, 0, 0.6, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[3].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.1, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.links[4].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.links[4].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[5].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.visual_init(camera, renderer, scene);

	// init interaction
	cursor = new Cursor(camera, renderer, scene);
	cursor.visual_init(camera, renderer, scene);

	orbitcontrols = new Orbitcontrols(camera, renderer, scene);

	//orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);

}

function render(){
	renderer.setSize(renderer.domElement.clientWidth,
			renderer.domElement.clientHeight, false);

	// adjust camera and renderer in response to any viewport size change.
	camera.aspect = renderer.domElement.clientWidth/
			renderer.domElement.clientHeight;
	camera.updateProjectionMatrix();

	// update controls
	
	// orbitcontrols.update();

	// render the scene as seen through camera.
	renderer.render(scene, camera);
}

var _t = 0;
function timestep(){
	_t += 0.01;

	manipulator.data_fromDH(null);
	manipulator.visual_sync();

	cursor.visual_sync();

	// testing orbitcontrols
	orbitcontrols.camera_fromqspherical();

	requestAnimationFrame(timestep);

	render();
}


</script>

</head>
<body>
	<canvas id="viewport">
	</canvas>

</body>
<script>init(); timestep(); </script>
</html>
