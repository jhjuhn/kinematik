<!DOCTYPE HTML>
<html>

<head>
<meta charset=utf-8>
<title>kinematik</title>

<style>
* { margin: 0; padding: 0; }
html, body {
	margin: 0;
	padding: 0;

	width: 100%;
	height: 100%;
}
#viewport {
	display: block;
	width: 100%;
	height: 100%;
}
</style>

<!-- external libraries -->
<script src="three.min.js"></script>
<script src="numeric-1.2.6.min.js"></script>


<script src="orbitcontrols.js"></script>

<script src="v4.js"></script>
<script src="denavithartenberg.js"></script>
<script src="frame.js"></script>

<script src="kinematik.js"></script>


<!-- cursor.js -->
<script>
// declarations for user interaction
function Cursor(camera, renderer, scene){

	this.camera = camera;
	this.renderer = renderer;

	this.raycaster = new THREE.Raycaster();

	this.q2d = [0, 0];
	this.q3d = [0, 0, 0, 1];

	this.marker2d = [0, 0];
	this.marker3d = [0, 0, 0, 1];

	this.visual = null;

	this.attachhandlers(camera, renderer, scene);

	return this;
}
Cursor.prototype.visual_init = function(camera, renderer, scene){
	// camera, renderer, scene are supplied for consistency, even
	// though the object has memory of camera & renderer upon
	// initialisation. If the parameters here are inconsistent with
	// the one supplied to the constructor, the class will calculate
	// the projection into one scene but draw the 3d cursor in another,
	// which is silly.

	if (this.visual !== null) {
		console.log("! repeated call to visual_init");
		return;
	}
	this.visual = {};
	
	// placeholder: sphere marks location of cursor.
	this.visual.centre = new THREE.Mesh(
			new THREE.SphereGeometry(0.01, 32, 32),
			new THREE.MeshBasicMaterial({color: 0x666666 })
			);
	scene.add(this.visual.centre);
}
Cursor.prototype.visual_sync = function(){
	if (this.visual === null) {
		console.log("! call to visual_sync without intialised visual");
		return;
	}
	this.visual.centre.position.fromArray(this.q3d);
}
Cursor.prototype.q2d_fromevent = function(e){
	// 2d (screen space) coordinates from mouse event.
	//
	// we use the canvas convention of coordinates with origin
	// at centre of element & coordinates normalised to
	// (-1, 1) along both axes.

	this.q2d[0] = e.clientX/e.target.clientWidth*2-1;
	this.q2d[1] = -e.clientY/e.target.clientHeight*2+1;
}
Cursor.prototype.q3d_fromevent = function(e) {

	var q2d = [e.clientX/e.target.clientWidth*2-1,
	-e.clientY/e.target.clientHeight*2+1];

	// 3d (scene space) coordinates:
	//
	// a ray is cast from cursor coordinates, and this.q3d is
	// moved to the point on that ray that leaves its distance to
	// the camera, along the camera's viewing vector, unchanged.

	this.raycaster.setFromCamera(
			new THREE.Vector2().fromArray(q2d),
			this.camera);

	var ray = v4fromTHREEVector3(this.raycaster.ray.direction);
	var origin = v4fromTHREEVector3(this.raycaster.ray.origin);
	var cameradirection = v4fromTHREEVector3(this.camera.getWorldDirection());

	// the distance down the cast ray to the intersection with the normal plane.
	var scale = v4dot(cameradirection, v4sub(this.q3d, origin))/v4dot(cameradirection, ray);

	this.q3d = v4add(origin, v4mul(scale, ray));

}
Cursor.prototype.mousemovehandler = function(e){
	this.q2d_fromevent(e);
	//this.q3d_fromevent(e);
}
Cursor.prototype.mousedownhandler = function(e){
	// move the cursor if it's the relevant button
	if (e.which == 1) { // LMB
		this.q2d_fromevent(e);
		this.q3d_fromevent(e);
	}

}
Cursor.prototype.wheelhandler = function(e){
	this.q2d_fromevent(e);
}
Cursor.prototype.attachhandlers = function(camera, renderer, scene) {
	renderer.domElement.addEventListener("mousemove",
			this.mousemovehandler.bind(this));
	renderer.domElement.addEventListener("mousedown",
			this.mousedownhandler.bind(this));
	renderer.domElement.addEventListener("wheel",
			this.wheelhandler.bind(this));
}
Cursor.prototype.update = function(){

}
</script>

<!-- main.js -->
<script>
var cursor;

// declarations for THREE
var camera;
var renderer;
var scene;

var orbitcontrols;

function initTHREE(){
	// initialise camera
	var canvas = document.getElementById("viewport");
	camera = new THREE.PerspectiveCamera(
		45,
		canvas.clientWidth/canvas.clientHeight,
		//window.innerWidth/window.innerHeight,
		0.1, 1000 );
	
	// initial position of camera
	camera.up.set(0, 0, 1);
	camera.position.z = 2;

	// initialise renderer and scene
	renderer = new THREE.WebGLRenderer({ canvas: canvas });
	scene = new THREE.Scene();

	scene.background = new THREE.Color(0xf4f4f4);

	// populate scene with reference plane and light
	var refplane = new THREE.Mesh(
			new THREE.PlaneGeometry(1, 1),
			new THREE.MeshBasicMaterial({ color: 0xfafafa }));
	scene.add(refplane);

	var ambientlight = new THREE.AmbientLight(0xffffff);
	scene.add(ambientlight);
	var directionallight = new THREE.DirectionalLight(0xffffff, 0.8);
	directionallight.position.set(10, 10, 10);
	scene.add(directionallight);


	// suppress mouse events
	renderer.domElement.addEventListener("contextmenu", function(e){ e.preventDefault(); });
}

// declarations for kinematik
var manipulator = null;
function init(){
	initTHREE(); // init webGL things

	// init manipulator
	manipulator = new kinematik.KinematicChain();
	manipulator.visual_init(camera, renderer, scene);

	// COMMENTED OUT: code to generate a random manipulator.
	/*
	var nextjq = [0, 0, 0, 1];
	var nextjz = [0, 0, 0, 1];
	for (var i = 0; i < 6; ++i) {
		nextjq.v4add(
		[Math.random(), Math.random(), Math.random(), 1].v4mul(0.15));
		nextjz = [Math.random(), Math.random(), Math.random(), 1];

		manipulator.pushlink();
		manipulator.links[i].data_fromjoint({
			jointtype: (Math.random() > 0.5 ? 1 : 2),
			jointlocation: nextjq,
			jointaxis: nextjz
		});
	}
	manipulator.visual_init(camera, renderer, scene);
	*/


	// typical anthropomorphic manipulator:
	for (var i = 0; i < 6; ++i) { manipulator.pushlink(); }
	manipulator.links[0].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0, 0.1, 1],
		jointaxis: [0, 0, 1, 1] });

	manipulator.links[1].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.12, 0, 0.2, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[2].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.1, 0, 0.6, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[3].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.1, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.links[4].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.links[4].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[5].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.visual_init(camera, renderer, scene);

	// init interaction
	cursor = new Cursor(camera, renderer, scene);
	cursor.visual_init(camera, renderer, scene);

	orbitcontrols = new Orbitcontrols(camera, renderer, scene);

	//orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);

}

function render(){
	renderer.setSize(renderer.domElement.clientWidth,
			renderer.domElement.clientHeight, false);

	// adjust camera and renderer in response to any viewport size change.
	camera.aspect = renderer.domElement.clientWidth/
			renderer.domElement.clientHeight;
	camera.updateProjectionMatrix();


	// update visual for the manipulator
	manipulator.visual_sync();

	// update controls
	cursor.update();
	cursor.visual_sync();

	orbitcontrols.update();
	orbitcontrols.visual_sync();


	// render the scene as seen through camera.
	renderer.render(scene, camera);
}

var _t = 0;
function timestep(){
	_t += 0.01;

	manipulator.data_fromDH(null);

	requestAnimationFrame(timestep);

	render();
}


</script>

</head>
<body>
	<canvas id="viewport">
	</canvas>

</body>
<script>init(); timestep(); </script>
</html>
