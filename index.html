<!DOCTYPE HTML>
<html>

<head>
<meta charset=utf-8>
<title>kinematik</title>

<style>
* { margin: 0; padding: 0; }
html, body {
	margin: 0;
	padding: 0;

	width: 100%;
	height: 100%;
}
#viewport {
	display: block;
	width: 100%;
	height: 100%;
}
</style>

<!-- external libraries -->
<script src="three.min.js"></script>
<script src="numeric-1.2.6.min.js"></script>


<script src="orbitcontrols.js"></script>

<script src="v4.js"></script>
<script src="denavithartenberg.js"></script>
<script src="frame.js"></script>
<script src="cursor.js"></script>

<script src="kinematik.js"></script>


<!-- main.js -->
<script>
var cursor;

// declarations for THREE
var camera;
var renderer;
var scene;

var orbitcontrols;

function initTHREE(){
	// initialise camera
	var canvas = document.getElementById("viewport");
	camera = new THREE.PerspectiveCamera(
		45,
		canvas.clientWidth/canvas.clientHeight,
		//window.innerWidth/window.innerHeight,
		0.1, 1000 );
	
	// initial position of camera
	camera.up.set(0, 0, 1);
	camera.position.z = 2;

	// initialise renderer and scene
	renderer = new THREE.WebGLRenderer({ canvas: canvas });
	scene = new THREE.Scene();

	scene.background = new THREE.Color(0xf4f4f4);

	// populate scene with reference plane and light
	var refplane = new THREE.Mesh(
			new THREE.PlaneGeometry(1, 1),
			new THREE.MeshBasicMaterial({ color: 0xfafafa }));
	scene.add(refplane);

	var ambientlight = new THREE.AmbientLight(0xffffff);
	scene.add(ambientlight);
	var directionallight = new THREE.DirectionalLight(0xffffff, 0.8);
	directionallight.position.set(10, 10, 10);
	scene.add(directionallight);


	// suppress mouse events
	renderer.domElement.addEventListener("contextmenu", function(e){ e.preventDefault(); });
}

// declarations for kinematik
var manipulator = null;
function init(){
	initTHREE(); // init webGL things

	// init manipulator
	manipulator = new kinematik.KinematicChain();
	manipulator.visual_init(camera, renderer, scene);

	// COMMENTED OUT: code to generate a random manipulator.
	/*
	var nextjq = [0, 0, 0, 1];
	var nextjz = [0, 0, 0, 1];
	for (var i = 0; i < 6; ++i) {
		nextjq.v4add(
		[Math.random(), Math.random(), Math.random(), 1].v4mul(0.15));
		nextjz = [Math.random(), Math.random(), Math.random(), 1];

		manipulator.pushlink();
		manipulator.links[i].data_fromjoint({
			jointtype: (Math.random() > 0.5 ? 1 : 2),
			jointlocation: nextjq,
			jointaxis: nextjz
		});
	}
	manipulator.visual_init(camera, renderer, scene);
	*/


	// typical anthropomorphic manipulator:
	for (var i = 0; i < 6; ++i) { manipulator.pushlink(); }
	manipulator.links[0].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0, 0.1, 1],
		jointaxis: [0, 0, 1, 1] });

	manipulator.links[1].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.12, 0, 0.2, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[2].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0.1, 0, 0.6, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[3].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.1, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.links[4].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.links[4].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [1, 0, 0, 1] });

	manipulator.links[5].data_fromjoint({
		jointtype: KINEMATIK_JOINTTYPE_REVOLUTE,
		jointlocation: [0, 0.3, 0.7, 1],
		jointaxis: [0, 1, 0, 1] });

	manipulator.visual_init(camera, renderer, scene);

	// init interaction
	cursor = new Cursor(camera, renderer, scene);
	cursor.visual_init(camera, renderer, scene);

	orbitcontrols = new Orbitcontrols(camera, renderer, scene);

	//orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);

}

function render(){
	renderer.setSize(renderer.domElement.clientWidth,
			renderer.domElement.clientHeight, false);

	// adjust camera and renderer in response to any viewport size change.
	camera.aspect = renderer.domElement.clientWidth/
			renderer.domElement.clientHeight;
	camera.updateProjectionMatrix();


	// update visual for the manipulator
	manipulator.visual_sync();

	// update controls
	cursor.update();
	cursor.visual_sync();

	orbitcontrols.update();
	orbitcontrols.visual_sync();


	// render the scene as seen through camera.
	renderer.render(scene, camera);
}

var _t = 0;
function timestep(){
	_t += 0.01;

	manipulator.data_fromDH(null);

	requestAnimationFrame(timestep);

	render();
}


</script>

</head>
<body>
	<canvas id="viewport">
	</canvas>

</body>
<script>init(); timestep(); </script>
</html>
