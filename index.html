<!DOCTYPE HTML>
<html>

<head>
<meta charset=utf-8>
<title>kinematik</title>

<style>
* { margin: 0; padding: 0; }
html, body {
	margin: 0;
	padding: 0;
}
canvas { display: block; }
</style>

<script src="three.min.js"></script>
<script src="three.orbitcontrols.js"></script>
<script src="numeric-1.2.6.min.js"></script>
<!-- frame.js -->
<script>

var FRAME_MATERIAL_R = new THREE.MeshBasicMaterial({ color: 0xff0000 });
var FRAME_MATERIAL_G = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
var FRAME_MATERIAL_B = new THREE.MeshBasicMaterial({ color: 0x0000ff });

var FRAME_GEOMETRY_AXIS_LENGTH = 1;
var FRAME_GEOMETRY_CONE_HEIGHT = FRAME_GEOMETRY_AXIS_LENGTH*0.4;
var FRAME_GEOMETRY_CONE_THICKNESS = FRAME_GEOMETRY_AXIS_LENGTH*0.1;
var FRAME_GEOMETRY_CYLINDER_HEIGHT = FRAME_GEOMETRY_AXIS_LENGTH-FRAME_GEOMETRY_CONE_HEIGHT;
var FRAME_GEOMETRY_CYLINDER_THICKNESS = FRAME_GEOMETRY_AXIS_LENGTH*0.03;

var FRAME_GEOMETRY_CONE = new THREE.ConeGeometry(
		FRAME_GEOMETRY_CONE_THICKNESS,
		FRAME_GEOMETRY_CONE_HEIGHT, 8);
var FRAME_GEOMETRY_CYLINDER = new THREE.CylinderGeometry(
		FRAME_GEOMETRY_CYLINDER_THICKNESS,
		FRAME_GEOMETRY_CYLINDER_THICKNESS,
		FRAME_GEOMETRY_CYLINDER_HEIGHT, 8);
function Frame(){
	this.o = [0, 0, 0, 1];
	this.axis = [
		[1, 0, 0, 1],
		[0, 1, 0, 1],
		[0, 0, 1, 1]
		];
	return this;	
}
Frame.prototype.visual_init = function(camera, renderer, scene){
	// guard against repeated calls to prevent leaving garbage objects in scene.
	if (this.visual !== undefined) {
		console.log("! repeated call to visual_init");
		return;
	}

	// naming convention: [object].[property] has [object].visual.[property] as
	// visual representation in scene. visual may contain more than one part.
	this.visual = {};
	this.visual.axis = [
		{ cone: new THREE.Mesh(FRAME_GEOMETRY_CONE, FRAME_MATERIAL_R),
		  cylinder: new THREE.Mesh(FRAME_GEOMETRY_CYLINDER, FRAME_MATERIAL_R) },
		{ cone: new THREE.Mesh(FRAME_GEOMETRY_CONE, FRAME_MATERIAL_G),
		  cylinder: new THREE.Mesh(FRAME_GEOMETRY_CYLINDER, FRAME_MATERIAL_G) },
		{ cone: new THREE.Mesh(FRAME_GEOMETRY_CONE, FRAME_MATERIAL_B),
		  cylinder: new THREE.Mesh(FRAME_GEOMETRY_CYLINDER, FRAME_MATERIAL_B) }
	];

	for (var i = 0; i < 3; ++i){
		scene.add(this.visual.axis[i].cone);
		scene.add(this.visual.axis[i].cylinder);
	}
	return;
}
Frame.prototype.visual_sync = function() {
	// guard against updates before the representations have been created.
	if (!this.visual) {
		console.log("! visual_sync called before visual_init");
		return;
	}

	var j = 0;
	var offsetcone = FRAME_GEOMETRY_CYLINDER_HEIGHT+FRAME_GEOMETRY_CONE_HEIGHT/2;
	var offsetcylinder = FRAME_GEOMETRY_CYLINDER_HEIGHT/2;
	for (var i = 0; i < 3; ++i) {
		j = (i+1 == 3) ? 0 : i+1;
		this.visual.axis[i].cone.position.set(
			this.o[0]+this.axis[i][0]*offsetcone,
			this.o[1]+this.axis[i][1]*offsetcone,
			this.o[2]+this.axis[i][2]*offsetcone);
		this.visual.axis[i].cone.up.fromArray(this.axis[i]);
		this.visual.axis[i].cone.lookAt(
			new THREE.Vector3(
			this.o[0]+(this.axis[j][0]+this.axis[i][0])*offsetcone,
			this.o[1]+(this.axis[j][1]+this.axis[i][1])*offsetcone,
			this.o[2]+(this.axis[j][2]+this.axis[i][2])*offsetcone)
			);

		this.visual.axis[i].cylinder.position.set(
			this.o[0]+this.axis[i][0]*offsetcylinder,
			this.o[1]+this.axis[i][1]*offsetcylinder,
			this.o[2]+this.axis[i][2]*offsetcylinder);
		this.visual.axis[i].cylinder.up.fromArray(this.axis[i]);
		this.visual.axis[i].cylinder.lookAt(
			new THREE.Vector3(
			this.o[0]+(this.axis[j][0]+this.axis[i][0])*offsetcylinder,
			this.o[1]+(this.axis[j][1]+this.axis[i][1])*offsetcylinder,
			this.o[2]+(this.axis[j][2]+this.axis[i][2])*offsetcylinder)
			);
	}

	
}
var f1 = new Frame();
</script>

<!-- main.js -->
<script>
var camera;
var renderer;
var scene;

var orbitcontrols;

function initTHREE(){
	camera = new THREE.PerspectiveCamera(
		45,
		window.innerWidth/window.innerHeight,
		0.1, 1000 );

	renderer = new THREE.WebGLRenderer();
	scene = new THREE.Scene();
	document.body.appendChild(renderer.domElement);

}

function init(){
	initTHREE();
	
	var f = new Frame();
	f.visual_init(camera, renderer, scene);
	f.visual_sync();

	camera.position.z = 1;

	orbitcontrols = new THREE.OrbitControls(camera, renderer.domElement);
}

function render(){
	camera.aspect = window.innerWidth/window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize(window.innerWidth, window.innerHeight);

	renderer.render(scene, camera);
}

function timestep(){
	requestAnimationFrame(timestep);

	render();
}


</script>

</head>
<body></body>
<script>init(); timestep(); </script>
</html>
